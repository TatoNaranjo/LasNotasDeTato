"use strict";
/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ChordLyrics
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/line/Line.ts
var Line = class {
  constructor(content, lineType) {
    this.content = content;
    this.lineType = lineType;
  }
};

// src/line/findLines.ts
function findLines(text2) {
  return text2.split("\n").map((line2) => getTypedLine(line2));
}
function getTypedLine(line2) {
  const trimmed = line2.trim();
  if (trimmed.length == 0 || trimmed == "\n" || trimmed == "\r\n")
    return new Line(line2, 2 /* Empty */);
  if (trimmed.startsWith("[") && trimmed.endsWith("]"))
    return new Line(trimmed.substring(1, line2.length - 1), 3 /* Header */);
  if (trimmed.endsWith("%c"))
    return new Line(line2.trimEnd().substring(0, line2.length - 2), 0 /* Chord */);
  if (trimmed.endsWith("%t"))
    return new Line(line2.trimEnd().substring(0, line2.length - 2), 1 /* Text */);
  const numSpaces = line2.split(" ").length - 1;
  const spaceToContentRatio = numSpaces / line2.length;
  if (spaceToContentRatio > 0.3)
    return new Line(line2, 0 /* Chord */);
  return new Line(line2, 1 /* Text */);
}

// src/chunk/Chunk.ts
var Chunk = class {
  constructor(chunkType, content, content2) {
    this.chunkType = chunkType;
    this.content = content ? content : "";
    this.content2 = content2 ? content2 : "";
  }
};

// src/chunk/findTwoLineChunks.ts
function findTwoLineChunks(line1, line2) {
  [line1, line2] = matchLengthWithWhitespace(line1, line2);
  return findChunks(line1, getWordIndices(line1), line2, getWordIndices(line2));
}
function getWordIndices(text2) {
  const indices = [];
  for (const word2 of text2.matchAll(/\S+/g)) {
    if (word2.index != null)
      indices.push(word2.index);
  }
  return indices;
}
function findChunks(line1, line1Indices, line2, line2Indices) {
  const chunks2 = [];
  let lastCut = 0;
  let index1 = line1Indices.shift();
  let index2 = line2Indices.shift();
  while (index1 != void 0 || index2 != void 0) {
    if (index1 != void 0 && (index2 == void 0 || index1 <= index2)) {
      if (cutPossible(line2, index1, lastCut)) {
        chunks2.push(cut(lastCut, index1, line1, line2));
        lastCut = index1;
      }
      index1 = line1Indices.shift();
    } else if (index2 != void 0) {
      if (cutPossible(line1, index2, lastCut)) {
        chunks2.push(cut(lastCut, index2, line1, line2));
        lastCut = index2;
      }
      index2 = line2Indices.shift();
    }
  }
  chunks2.push(cut(lastCut, line1.length, line1, line2));
  return chunks2;
}
function matchLengthWithWhitespace(chordLine, textLine) {
  const diff = Math.abs(chordLine.length - textLine.length);
  if (chordLine.length > textLine.length)
    textLine += " ".repeat(diff);
  else
    chordLine += " ".repeat(diff);
  return [chordLine, textLine];
}
function cutPossible(str, index, lastCutIndex) {
  if (index === lastCutIndex)
    return false;
  const charLeftOfCut = str.charAt(index - 1);
  const charRightOfCut = str.charAt(index);
  return index !== 0 && (charLeftOfCut === " " || charRightOfCut === " ");
}
function cut(beginning, end, chordLine, textLine) {
  const chordPart = chordLine.substring(beginning, end);
  const textPart = textLine.substring(beginning, end);
  return new Chunk(4 /* ChordWithText */, chordPart, textPart);
}

// src/chunk/findChunks.ts
function findChunks2(lines2) {
  const nextLineIsText = () => lineNumber + 1 < lines2.length && lines2[lineNumber + 1].lineType == 1 /* Text */;
  function handleChordLine(group, line2) {
    if (nextLineIsText()) {
      group.push(...findTwoLineChunks(line2.content, lines2[lineNumber + 1].content));
      lineNumber++;
    } else
      group.push(...getSingleLineChordChunks(line2.content));
  }
  const chunks2 = [];
  let lineNumber = 0;
  while (lineNumber < lines2.length) {
    const group = [];
    const line2 = lines2[lineNumber];
    switch (line2.lineType) {
      case 2 /* Empty */:
        group.push(new Chunk(2 /* Empty */));
        break;
      case 3 /* Header */:
        group.push(new Chunk(3 /* Header */, line2.content));
        break;
      case 1 /* Text */:
        group.push(...getSingleLineWordChunks(line2.content));
        break;
      case 0 /* Chord */:
        handleChordLine(group, line2);
        break;
    }
    lineNumber++;
    chunks2.push(group);
  }
  return chunks2;
}
function getSingleLineChordChunks(line2) {
  return getSingleLineChunks(line2, 0 /* Chord */);
}
function getSingleLineWordChunks(line2) {
  return getSingleLineChunks(line2, 1 /* Word */);
}
function getSingleLineChunks(line2, chunkType) {
  const chunks2 = [];
  const matches = line2.match(/\s*\S+\s*/g);
  if (matches != null) {
    matches.forEach((str) => chunks2.push(new Chunk(chunkType, str)));
  }
  return chunks2;
}

// src/output/createHtml.ts
var el = (tag, children, ...classes) => {
  const el2 = document.createElement(tag);
  el2.append(...children);
  classes.forEach((c) => el2.classList.add(c));
  return el2;
};
var div = (children, ...classes) => el("div", children, ...classes);
var text = (content) => document.createTextNode(content);
var stack = (chord2, text2) => div([chord2, text2], "chordlyrics-stack");
var chord = (content) => div([text(content)], "chordlyrics-chord", "cm-strong");
var header = (content) => div([text(content)], "chordlyrics-header");
var word = (content) => div([text(content)], "chordlyrics-word");
var line = (children) => div(children, "chordlyrics-line");
var chordWithText = (c, t) => stack(chord(c), word(t));
var chunks = (chunk) => {
  switch (chunk.chunkType) {
    case 2 /* Empty */:
      return word(chunk.content);
    case 3 /* Header */:
      return header(chunk.content);
    case 1 /* Word */:
      return word(chunk.content);
    case 0 /* Chord */:
      return chord(chunk.content);
    case 4 /* ChordWithText */:
      return chordWithText(chunk.content, chunk.content2);
  }
};
var lines = (group) => line(group.map((c) => chunks(c)));
var root = (lines2) => el("pre", lines2, "chordlyrics-root");
var createHtml_default = (groups) => root(groups.map((g) => lines(g)));

// src/settings/SettingsTab.ts
var import_obsidian = require("obsidian");
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const add = (name, enable, setEnable, color, setColor) => {
      new import_obsidian.Setting(containerEl).setName(`Customize ${name} color`).setDesc(`Use your own ${name} color instead of using the theme color`).setTooltip(`If you don't like how the ${name} color looks with your theme, choose another color here.`).addToggle((toggle) => toggle.setValue(enable != null ? enable : false).onChange(async (value) => {
        setEnable(value);
        await this.plugin.saveSettings();
      })).addColorPicker((col) => col.setValue(color != null ? color : "#000000").onChange(async (value) => {
        setColor(value);
        await this.plugin.saveSettings();
      }));
    };
    let { containerEl } = this;
    containerEl.empty();
    const s = this.plugin.getSettings().customColors;
    add("chord", s.enableChord, (e) => s.enableChord = e, s.chord, (c) => s.chord = c);
    add("background", s.enableBackground, (e) => s.enableBackground = e, s.background, (c) => s.background = c);
    add("header background", s.enableHeaderBackground, (e) => s.enableHeaderBackground = e, s.headerBackground, (c) => s.headerBackground = c);
    add("header text", s.enableHeaderText, (e) => s.enableHeaderText = e, s.headerText, (c) => s.headerText = c);
    add("lyrics", s.enableLyrics, (e) => s.enableLyrics = e, s.lyrics, (c) => s.lyrics = c);
  }
};

// src/settings/DefaultSettings.ts
var DEFAULT_SETTINGS = {
  customColors: {
    enableChord: false,
    chord: "#ffffff",
    enableBackground: false,
    background: "#000000",
    enableHeaderBackground: false,
    headerBackground: "#222222",
    enableHeaderText: false,
    headerText: "#eeeeee",
    enableLyrics: false,
    lyrics: "#dddddd"
  }
};

// main.ts
var ChordLyrics = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = Object.assign({});
    this.CODE_BLOCK_TRIGGER = "chordlyrics";
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    this.applySettings();
    this.registerMarkdownCodeBlockProcessor(this.CODE_BLOCK_TRIGGER, this.getProcessor());
    console.log(`Chord Lyrics: version ${this.manifest.version} (requires obsidian ${this.manifest.minAppVersion})`);
  }
  getSettings() {
    return this.settings;
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.applySettings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  getProcessor() {
    return function(text2, html) {
      const lines2 = findLines(text2);
      const chunks2 = findChunks2(lines2);
      const styled = createHtml_default(chunks2);
      html.appendChild(styled);
    };
  }
  applySettings() {
    const addProp = (name, val) => document.documentElement.style.setProperty(name, val);
    const delProp = (name) => document.documentElement.style.removeProperty(name);
    const apply = (enable, name, val) => enable ? addProp(name, val) : delProp(name);
    const s = this.settings.customColors;
    apply(s.enableChord, "--chordlyrics-chord-color", s.chord);
    apply(s.enableBackground, "--chordlyrics-background-color", s.background);
    apply(s.enableHeaderBackground, "--chordlyrics-header-background-color", s.headerBackground);
    apply(s.enableHeaderText, "--chordlyrics-header-text-color", s.headerText);
    apply(s.enableLyrics, "--chordlyrics-lyrics-color", s.lyrics);
  }
};
